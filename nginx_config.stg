/*
 * Mandatory:
 *
 * vars.gitea.nginx.workerProcesses
 * vars.gitea.nginx.workerConnections
 *
 */
nginxDefaults(parent, vars) ::= <<
worker_processes <vars.gitea.nginx.workerProcesses>;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;
events {
  worker_connections  <vars.gitea.nginx.workerConnections>;
}
>>

/*
 * Mandatory:
 *
 * vars.gitea.nginx.workerProcesses
 * vars.gitea.nginx.workerConnections
 *
 */
nginxHttpDefaults(parent, vars) ::= <<
include /etc/nginx/mime.types;
default_type application/octet-stream;
log_format   main '$remote_addr - $remote_user [$time_local]  $status '
    '"$request" $body_bytes_sent "$http_referer" '
    '"$http_user_agent" "$http_x_forwarded_for"';
log_format upstream_time '$remote_addr - $remote_user [$time_local] '
                          '"$request" $status $body_bytes_sent '
                          '"$http_referer" "$http_user_agent"'
                          'rt=$request_time uct="$upstream_connect_time" uht="$upstream_header_time" urt="$upstream_response_time"';
access_log /var/log/nginx/access.log  main;
access_log /var/log/nginx/access-upstream-time.log.gz  upstream_time gzip flush=5m;
sendfile on;
tcp_nopush on;
tcp_nodelay on;
gzip on;
keepalive_timeout 65;
index index.php index.html index.htm;
client_max_body_size <vars.gitea.nginx.clientMaxBodySize>;
>>

/*
 *
 */
nginxRootProxyPassBackendLocationConfig(parent, vars) ::= <<
proxy_read_timeout      <vars.gitea.nginx.readTimeout>;
proxy_connect_timeout   <vars.gitea.nginx.readTimeout>;
proxy_redirect      off;
proxy_http_version  1.1;
proxy_pass          http://backend;
>>

/*
 * vars.gitea.nginx.hosts[]
 */
nginxVirtualHosts(parent, vplars) ::= <<
  <rest(vars.gitea.nginx.hosts):redirectHost(parent, vars);separator="\n">
>>

/*
 * vars.gitea.nginx.hosts[]
 */
redirectHost(host, parent, vars) ::= <<
server {
  root /var/www/html;
  server_name <host>;
  return 301 https://<first(vars.gitea.nginx.hosts)>$request_uri;
}
>>

/*
 *
 */
nginxDefaultLocations(parent, vars) ::= <<
<nginxLocationStaticFiles(parent, vars)>
<nginxLocationFavicon(parent, vars)>
<nginxLocationRobots(parent, vars)>
<nginxLocationHidden(parent, vars)>
>>

/*
 *
 */
nginxLocationStaticFiles(parent, vars) ::= <<
## All static files will be served directly.
location ~* ^.+\.(?:css|js|jpe?g|gif|htc|ico|png|html)$ {
    <nginxLocationStaticFilesConfig(parent, vars)>
}
>>

/*
 *
 */
nginxLocationStaticFilesConfig(parent, vars) ::= <<
#access_log off;
expires 30d;
## No need to bleed constant updates.
## Send the all shebang in one fell swoop.
tcp_nodelay off;
## Set the OS file cache.
open_file_cache max=3000 inactive=120s;
open_file_cache_valid 45s;
open_file_cache_min_uses 2;
open_file_cache_errors off;
>>

/*
 *
 */
nginxLocationFavicon(parent, vars) ::= <<
## Support for favicon.
## Return an 1x1 transparent GIF if it doesn't exist.
location = /favicon.ico {
    expires 30d;
    try_files /favicon.ico @empty;
    access_log off;
}
## Return an in memory 1x1 transparent GIF.
location @empty {
    expires 30d;
    empty_gif;
    access_log off;
}

/*
 *
 */
nginxLocationRobots(parent, vars) ::= <<
#
location = /robots.txt {
  allow all;
  log_not_found off;
  access_log off;
}
>>

nginxLocationHidden(parent, vars) ::= <<
# Deny all attempts to access hidden files such as .htaccess, .htpasswd, .DS_Store (Mac).
# Keep logging the requests to parse later (or to pass to firewall utilities such as fail2ban)
location ~ /\. {
  deny all;
}
>>

